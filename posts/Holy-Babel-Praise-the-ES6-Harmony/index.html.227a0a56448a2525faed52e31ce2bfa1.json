{"head":{"title":"Holy Babel! Praise the ES6 Harmony.","date":"2016-03-24T16:04:28.000Z","tags":"JavaScript","layout":"Post","hero":"../../assets/babel.png","description":"ECMAScript6 簡稱 ES6 或 ES2015 是 JavaScript 在 2015 年的最新進化，從前 js 都常被開發者們調侃是一個不好的語言，現在雖然當然還不夠好，但在持續的進化的過程中，每年推出新的 spec 的進度應該過不了多久就會成為超夢了吧～ ES6…"},"body":"<p><strong>ECMAScript6</strong> 簡稱 <strong>ES6</strong> 或 <strong>ES2015</strong> 是 JavaScript 在 2015 年的最新進化，從前 js 都常被開發者們調侃是一個不好的語言，現在雖然當然還不夠好，但在持續的進化的過程中，每年推出新的 spec 的進度應該過不了多久就會成為超夢了吧～</p>\n<p><strong>ES6</strong> 的最新進化多了好幾個技能可以學，它們讓 js 變得更加好用，這篇介紹主要涵蓋一下我個人認為比較常用、必學的技能，還有一些使用的時機和方式，讓大家都可以偷學幾招存進招式機裡哦！</p>\n<h2 id=\"prerequirement\"><a href=\"#prerequirement\" class=\"phenomic-HeadingAnchor\">#</a>Prerequirement</h2>\n<ul>\n<li>基本 JavaScript 語法</li>\n</ul>\n<h2 id=\"babel\"><a href=\"#babel\" class=\"phenomic-HeadingAnchor\">#</a>Babel</h2>\n<p>雖然 ES6 是 JavaScript 官方的進化，但是瀏覽器們卻還沒有全部跟上，很多功能都還沒加進去，或是根本沒有加任何功能，要想要搶先使用這些功能就必須先將自己的 code 做一些前處理的編譯，於是就出現了目前最受歡迎的編譯器 <a href=\"https://babeljs.io/\">Babel</a>，它除了可以讓你編譯 ES6 的原始碼以外，還可以編譯 ES7 或一些尚還在提案階段的新功能唷！使用前不妨造訪他們的網站吧，doc 我認為寫得相當清楚詳細。</p>\n<p>Babel 在使用的環境和狀況下會有不同的設定方式，以下簡單介紹幾種比較常見的設定方式，其餘在官網都有相當詳盡的說明。</p>\n<h3 id=\"browser-only\"><a href=\"#browser-only\" class=\"phenomic-HeadingAnchor\">#</a>Browser-only</h3>\n<p>假如一開始學習時沒有使用任何的 bundler system 的話，直接用 <code>&#x3C;script></code> tag 也許是最快最方便的一種方式了，使用方式很簡單，直接在 <code>&#x3C;head></code> 加入 CDN。</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\" https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/6.4.4/babel.min.js\"</span>></span><span class=\"null\"></span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">script</span>></span></code></pre>\n<p>之後的 script source 都可以直接使用囉！</p>\n<h3 id=\"nodejs\"><a href=\"#nodejs\" class=\"phenomic-HeadingAnchor\">#</a>Node.js</h3>\n<p>如果是後端的環境的話根據使用的情況也會有不同的方式，但最基本的還是直接安裝 <code>babel-cli</code> 就可以立即見效。另外要使用一些 ES6 的功能也要安裝 <code>preset-es2015</code>。</p>\n<pre><code class=\"hljs language-bash\">$ npm install --save-dev babel-cli babel-preset-es2015</code></pre>\n<p>新建一個叫做 <code>.babelrc</code> 的檔案，裡面告訴 Babel 要使用什麼樣的 preset。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// .babelrc</span>\n{ <span class=\"hljs-string\">\"presets\"</span>: [<span class=\"hljs-string\">\"es2015\"</span>] }</code></pre>\n<p>之後 <code>babel</code> 指令可以編譯原始碼，<code>babel-node</code> 可以執行原始碼或進入 REPL 模式。</p>\n<pre><code class=\"hljs language-bash\">$ babel src.js -o build.js <span class=\"hljs-comment\"># 將 src.js 編譯成 build.js</span>\n$ babel src/ <span class=\"hljs-_\">-d</span> dist/ -w <span class=\"hljs-comment\"># 將 src 目錄底下的 js 都編譯到 dist 目錄底下，且不斷檢查變更</span>\n$ babel-node src.js <span class=\"hljs-comment\"># 直接編譯並執行 src.js (相當於 node src.js)</span>\n$ babel-node <span class=\"hljs-comment\"># 進入 babel 的 REPL mode (相當於直接執行 node)</span></code></pre>\n<p>其中 <code>babel-node</code> 只適合使用在開發階段，正式上線時還是要使用預先編譯過後的版本。</p>\n<h3 id=\"bundler\"><a href=\"#bundler\" class=\"phenomic-HeadingAnchor\">#</a>Bundler</h3>\n<p>使用像 <code>webpack</code> 或是 <code>browserify</code> 之類的 bundler 時有各式的使用方法，這部分根據使用方式不同會有比較多的變化，請直接參考官網的教學囉 (其實是懶得寫)。</p>\n<h2 id=\"features\"><a href=\"#features\" class=\"phenomic-HeadingAnchor\">#</a>Features</h2>\n<h3 id=\"arrows-function\"><a href=\"#arrows-function\" class=\"phenomic-HeadingAnchor\">#</a>Arrows function</h3>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// es5</span>\n<span class=\"hljs-keyword\">var</span> foo = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">bar</span>) </span>{\n    <span class=\"hljs-comment\">// ...</span>\n};\n\n<span class=\"hljs-comment\">// es6</span>\n<span class=\"hljs-keyword\">var</span> foo = <span class=\"hljs-function\">(<span class=\"hljs-params\">bar</span>) =></span> {\n    <span class=\"hljs-comment\">// ...</span>\n};</code></pre>\n<p><strong>Arrows function</strong> 是一個 function 的 short hand 用法，除了簡化 <strong>function</strong> 的用法以外也會把 parent 的 <code>this</code> 正確的傳入 function 中，這是一個相當實用的功能，在很多情況下都非常好用。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// es5</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">this</span>.name = <span class=\"hljs-string\">\"hello\"</span>;\n\n    setTimeout(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>.name); <span class=\"hljs-comment\">// undefined</span>\n    }, <span class=\"hljs-number\">1000</span>);\n}\n\n<span class=\"hljs-comment\">// es6</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">this</span>.name = <span class=\"hljs-string\">\"hello\"</span>;\n\n    setTimeout(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =></span> {\n        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>.name); <span class=\"hljs-comment\">// hello</span>\n    }, <span class=\"hljs-number\">1000</span>);\n}</code></pre>\n<p>基本的用法簡單上來說是將 <code>function</code> 捨去，並在 arguments 和 function 的開頭 <code>{</code> 之前加入 arrow <code>=></code>，不過其他還有一些簡單的用法分別用在不同的情況。</p>\n<p>arguments 的使用方式：</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">var</span> foo = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =></span> {\n    <span class=\"hljs-comment\">// 沒有 argument 的 function</span>\n};\n\n<span class=\"hljs-keyword\">var</span> foo = <span class=\"hljs-function\"><span class=\"hljs-params\">bar</span> =></span> {\n    <span class=\"hljs-comment\">// 只有一個 argument 時可以省去括號</span>\n};\n\n<span class=\"hljs-keyword\">var</span> foo = <span class=\"hljs-function\">(<span class=\"hljs-params\">bar, bar2</span>) =></span> {\n    <span class=\"hljs-comment\">// 兩個以上時用 , 隔開</span>\n};</code></pre>\n<p>若沒有太多的步驟要執行，只要簡單的快速回傳值的話可以這麼寫：</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">var</span> foo = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =></span> bar;\n<span class=\"hljs-comment\">// 或</span>\n<span class=\"hljs-keyword\">var</span> foo = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =></span> (bar);\n<span class=\"hljs-comment\">// 相當於：</span>\n<span class=\"hljs-keyword\">var</span> foo = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =></span> {\n    <span class=\"hljs-keyword\">return</span> bar;\n};\n\n<span class=\"hljs-comment\">// 若要回傳一個 object 也可以這麼寫</span>\n<span class=\"hljs-keyword\">var</span> foo = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =></span> ({\n    <span class=\"hljs-attr\">bar</span>: <span class=\"hljs-string\">\"bar\"</span>\n});\n<span class=\"hljs-comment\">// 相當於：</span>\n<span class=\"hljs-keyword\">var</span> foo = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =></span> {\n    <span class=\"hljs-keyword\">return</span> {\n        <span class=\"hljs-attr\">bar</span>: <span class=\"hljs-string\">\"bar\"</span>\n    };\n};</code></pre>\n<p>簡單來說若要直接回傳值的話可以用小括號表示或直接省略，若是 object 的話因為直接省略會和 function 的 syntax 衝突，所以外面需要包一層小刮號。</p>\n<p><strong>Arrows function</strong> 在一般情況下非常好用，除了跟 <strong>functional programming</strong> 非常合以外，其他基本上所有的情況都最好使用 <strong>arrows function</strong> 來取代原本的 function。唯一的例外就是當內部的 <code>this</code> 有特別指定是自己的時候用 <strong>arrows function</strong> 會得到錯誤的值，這在一些針對舊式的 jQuery 的套件上滿常見的，這時候直接改用原本的 function syntax 就可以了。</p>\n<h3 id=\"let--const\"><a href=\"#let--const\" class=\"phenomic-HeadingAnchor\">#</a>Let &#x26; Const</h3>\n<p><code>let</code> 和 <code>const</code> 是在宣告變數時新的使用方式，原本的 <code>var</code> 是不夠嚴謹的，所以常常會得到意料之外的結果或 bug，<code>let</code> 只存在於你宣告的 block 裡面，可以解決許多問題。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// es5</span>\n<span class=\"hljs-keyword\">var</span> bar;\n\n(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n    bar = <span class=\"hljs-string\">\"hello\"</span>;\n})();\n\n<span class=\"hljs-keyword\">var</span> bar = <span class=\"hljs-string\">\"world\"</span>;\n\n<span class=\"hljs-built_in\">console</span>.log(bar); <span class=\"hljs-comment\">// world</span>\n\n<span class=\"hljs-comment\">// es6</span>\n<span class=\"hljs-keyword\">let</span> bar;\n\n{\n    bar = <span class=\"hljs-string\">\"hello\"</span>;\n};\n\n<span class=\"hljs-keyword\">let</span> bar = <span class=\"hljs-string\">\"world\"</span>; <span class=\"hljs-comment\">// ERROR! 重複宣告 bar</span></code></pre>\n<p>而 <code>const</code> 顧名思義就是一經宣告後就不變的變數，不允許改變也不允許重複宣告，不過對於 Object 和 Array 還是可以新增 key 或值的，只是一樣無法重複宣告。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> bar = <span class=\"hljs-string\">\"foo\"</span>; <span class=\"hljs-comment\">// const 宣告時一定要給予其值 (廢話)</span>\n\nbar = <span class=\"hljs-string\">\"hello\"</span>; <span class=\"hljs-comment\">// ERROR! 改變了 const 變數</span>\n\n<span class=\"hljs-keyword\">const</span> foo = [<span class=\"hljs-string\">\"hello\"</span>];\nfoo.push(<span class=\"hljs-string\">\"world\"</span>);\n<span class=\"hljs-built_in\">console</span>.log(foo); <span class=\"hljs-comment\">// [\"hello\", \"world\"]</span></code></pre>\n<p>至於最佳的使用情況是：<strong>幾乎任何情況，都應該使用 <code>let</code> 來取代 <code>var</code>。</strong> 而且，<strong>唯一的例外是，只要是不曾更改過的定值就優先使用 <code>const</code>。</strong> 簡單來說，所有情況都不應該再出現 <code>var</code> 囉～！<del>RIP <code>var</code> ~2015。</del></p>\n<h3 id=\"template-strings\"><a href=\"#template-strings\" class=\"phenomic-HeadingAnchor\">#</a>Template Strings</h3>\n<p>原本 js 的 string <code>'</code> 和 <code>\"</code> 都可以使用，並無什麼不同，但是卻缺少了一些方便好用的功能，而 <strong>Template strings</strong> 的 <code>`</code> 帶來了解決方案。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// es5</span>\n<span class=\"hljs-keyword\">var</span> bar = <span class=\"hljs-string\">\"hello\"</span>;\n<span class=\"hljs-keyword\">var</span> foo = <span class=\"hljs-string\">\"world\"</span>;\n<span class=\"hljs-keyword\">var</span> str = bar + <span class=\"hljs-string\">\", \"</span> + foo + <span class=\"hljs-string\">\"!\"</span>; <span class=\"hljs-comment\">// hello, world!</span>\n\n<span class=\"hljs-comment\">// es6</span>\n<span class=\"hljs-keyword\">const</span> bar = <span class=\"hljs-string\">\"hello\"</span>;\n<span class=\"hljs-keyword\">const</span> foo = <span class=\"hljs-string\">\"world\"</span>;\n<span class=\"hljs-keyword\">const</span> str = <span class=\"hljs-string\">`<span class=\"hljs-subst\">${bar}</span>, <span class=\"hljs-subst\">${foo}</span>!`</span>; <span class=\"hljs-comment\">// hello, world!</span></code></pre>\n<p><code>${}</code>帶來了簡單的方式讓我們可以任意塞變數進去，另外也可以輕易地辦到多行的 string。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// es5</span>\n<span class=\"hljs-keyword\">var</span> multiline = <span class=\"hljs-string\">\"bar foo foo \\\nbar bar foo\"</span>;\n\n<span class=\"hljs-comment\">// es6</span>\n<span class=\"hljs-keyword\">const</span> multiline = <span class=\"hljs-string\">`bar foo foo\nbar bar foo`</span>;</code></pre>\n<p>這些功能在處理 url 的 get 等等的情況下特別好用，但在一般情況下沒有變數或是多行的需求時是可以用一般的方式的。</p>\n<h3 id=\"default\"><a href=\"#default\" class=\"phenomic-HeadingAnchor\">#</a>Default</h3>\n<p>原本 js 的 function 不支援 default value，所以常常必須在 function 裡面做類似下面的處理，但有了 default 後就可以直接指定預設的值。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// es5</span>\n<span class=\"hljs-keyword\">var</span> bar = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">foo</span>) </span>{\n    foo = foo || <span class=\"hljs-string\">\"hello\"</span>; <span class=\"hljs-comment\">// 注意，這是不夠嚴謹的作法</span>\n    <span class=\"hljs-keyword\">return</span> foo;\n};\n\n<span class=\"hljs-built_in\">console</span>.log(bar()); <span class=\"hljs-comment\">// hello</span>\n\n<span class=\"hljs-comment\">// es6</span>\n<span class=\"hljs-keyword\">const</span> bar = <span class=\"hljs-function\">(<span class=\"hljs-params\">foo = <span class=\"hljs-string\">\"hello\"</span></span>) =></span> {\n    <span class=\"hljs-keyword\">return</span> foo;\n};\n\n<span class=\"hljs-built_in\">console</span>.log(bar()); <span class=\"hljs-comment\">// hello</span></code></pre>\n<p>原本要寫出正確的 code 常常會寫得很長，而且如果又有很多個變數時更是痛苦，有了 default value 後就方便許多啦！</p>\n<h3 id=\"spread--rest\"><a href=\"#spread--rest\" class=\"phenomic-HeadingAnchor\">#</a>Spread &#x26; Rest</h3>\n<p>這可能是對一般人來說最神奇的一個新功能，不過實在是非常的好用呀～廢話不多說直接看範例比較好懂。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> foo = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];\n\n<span class=\"hljs-keyword\">const</span> bar = [...foo, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>];\n\n<span class=\"hljs-built_in\">console</span>.log(bar); <span class=\"hljs-comment\">// [1, 2, 3, 4, 5, 6]</span></code></pre>\n<p>簡單來說可以想成它把 Array 拆開成一個一個個別的值放進另一個 Array 裡面，然後會自然的很完美的 fit 進去，太神奇了神奇到我都不太會解釋了 XD，多多使用就會習慣了啦～</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 可以隨意放在任何位置</span>\n<span class=\"hljs-keyword\">const</span> foo = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>];\n<span class=\"hljs-keyword\">const</span> bar = [<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>];\n<span class=\"hljs-built_in\">console</span>.log( [...foo, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, ...bar] ); <span class=\"hljs-comment\">// [1, 2, 3, 4, 5, 6]</span>\n\n<span class=\"hljs-comment\">// better Array.push()</span>\n<span class=\"hljs-keyword\">const</span> foo = [<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>];\n<span class=\"hljs-keyword\">const</span> bar = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>];\nbar.push(...foo);\n<span class=\"hljs-built_in\">console</span>.log(bar); <span class=\"hljs-comment\">// [1, 2, 3, 4]</span></code></pre>\n<p>除了 Array 以外 Object 也是可以使用的，這樣的用法在需要覆蓋原本的 Object 值時非常常用，在 <strong>Redux</strong> 官方中也是推薦這種作法。<strong>不過要在 Object 中使用需要使用 <code>babel-preset-stage-2</code> 的 preset。</strong></p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> foo = {\n    <span class=\"hljs-string\">\"key1\"</span>: <span class=\"hljs-string\">\"value1\"</span>,\n    <span class=\"hljs-string\">\"key2\"</span>: <span class=\"hljs-string\">\"value2\"</span>\n};\n\n<span class=\"hljs-keyword\">const</span> bar = {\n    ...foo,\n    <span class=\"hljs-string\">\"key2\"</span>: <span class=\"hljs-string\">\"new value\"</span>,\n    <span class=\"hljs-string\">\"key3\"</span>: <span class=\"hljs-string\">\"value3\"</span>\n};\n\n<span class=\"hljs-built_in\">console</span>.log(bar); <span class=\"hljs-comment\">// { key1: 'value1', key2: 'new value', key3: 'value3' }</span></code></pre>\n<p>在 Object 中使用時放置的時機很重要，<strong>放在後面的會覆蓋掉前面存在過的 key</strong>。</p>\n<p>這樣的功能也同樣可以使用在 function 的 arguments 內，而這就是 <strong>Rest</strong>，而這只可以使用在 Array 上。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> foo = <span class=\"hljs-function\">(<span class=\"hljs-params\">...bar</span>) =></span> {\n    <span class=\"hljs-keyword\">return</span> bar.length;\n};\n\n<span class=\"hljs-built_in\">console</span>.log(foo(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>)); <span class=\"hljs-comment\">// 3</span></code></pre>\n<p>很神奇地把一個一個分開的 argument 轉成一個 Array 丟給 function 了！如果覺得這東西會太神奇的話就慢慢習慣吧哈哈～不過這已經在許多程式語言中是相當常見的語法了。</p>\n<h3 id=\"destructuring\"><a href=\"#destructuring\" class=\"phenomic-HeadingAnchor\">#</a>Destructuring</h3>\n<p><em>解構</em> 是一個特殊的語法可以讓你把一個 Array 或 Object 中的值提取出來另存在一個變數裡，這在 <strong>React</strong> 的拿取 <code>props</code> 的過程中也是非常常見的用法。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> [bar, foo] = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>];\n<span class=\"hljs-built_in\">console</span>.log(bar, foo); <span class=\"hljs-comment\">// 1, 2</span>\n\n<span class=\"hljs-keyword\">const</span> { bar, foo } = { <span class=\"hljs-attr\">bar</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-number\">2</span> };\n<span class=\"hljs-built_in\">console</span>.log(bar, foo); <span class=\"hljs-comment\">// 1, 2</span></code></pre>\n<p>另外也可以使用在 function 的 arguments 中。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> bar = <span class=\"hljs-function\">(<span class=\"hljs-params\">{ foo }</span>) =></span> {\n    <span class=\"hljs-keyword\">return</span> foo;\n};\n\n<span class=\"hljs-built_in\">console</span>.log( bar({ <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-number\">1</span> }) ); <span class=\"hljs-comment\">// 1</span></code></pre>\n<p>搭配 <strong>Default</strong> 可以有更好的寫法。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> bar = <span class=\"hljs-function\">(<span class=\"hljs-params\">{ foo, key = <span class=\"hljs-number\">2</span> }</span>) =></span> {\n    <span class=\"hljs-keyword\">return</span> foo + key;\n};\n\n<span class=\"hljs-built_in\">console</span>.log( bar({ <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-number\">1</span> }) ); <span class=\"hljs-comment\">// 3</span></code></pre>\n<h3 id=\"enhanced-object-literals\"><a href=\"#enhanced-object-literals\" class=\"phenomic-HeadingAnchor\">#</a>Enhanced Object Literals</h3>\n<p>在創建 Object 的時候有了更好的方法。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> foo = <span class=\"hljs-number\">1</span>;\n\n<span class=\"hljs-keyword\">const</span> bar = {\n    foo,\n    sayHi() {\n        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"Hi\"</span>);\n    },\n    [<span class=\"hljs-string\">`item<span class=\"hljs-subst\">${foo}</span>`</span>]: <span class=\"hljs-string\">`value<span class=\"hljs-subst\">${foo}</span>`</span>\n};\n\n<span class=\"hljs-built_in\">console</span>.log(bar); <span class=\"hljs-comment\">// { foo: 1, sayHi: [Function: sayHi], item1: 'value1' }</span>\nbar.sayHi(); <span class=\"hljs-comment\">// Hi</span></code></pre>\n<p>其中 <code>foo</code> 就是 <code>foo: foo</code> 的縮寫，這在使用 Object 時也是很常用的小技巧 (<em>有仔細注意的話會發現上面 Destructuring 的例子就是這個技巧的延伸</em>)。</p>\n<h3 id=\"class\"><a href=\"#class\" class=\"phenomic-HeadingAnchor\">#</a>Class</h3>\n<p>相信如果有接觸過其他的程式語言的話就會知道 Class 是什麼東西，今天 js 終於也有了它啦～痛哭流涕～。包含了基本的 constructor 和繼承的使用，這裡就不贅述，如果不懂 Class 是什麼的話找一個比較詳細的教學文來看會比較好哦～</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Car</span> </span>{\n    <span class=\"hljs-keyword\">constructor</span>(color) {\n        <span class=\"hljs-keyword\">this</span>.type = <span class=\"hljs-string\">\"car\"</span>;\n        <span class=\"hljs-keyword\">this</span>.color = color;\n    }\n\n    drive() {\n        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`GO! My <span class=\"hljs-subst\">${<span class=\"hljs-keyword\">this</span>.color}</span> <span class=\"hljs-subst\">${<span class=\"hljs-keyword\">this</span>.type}</span>!`</span>);\n    }\n}\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Taxi</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Car</span> </span>{\n    <span class=\"hljs-keyword\">constructor</span>(color) {\n        <span class=\"hljs-keyword\">super</span>(color);\n        <span class=\"hljs-keyword\">this</span>.type = <span class=\"hljs-string\">\"taxi\"</span>;\n    }\n}\n\n<span class=\"hljs-keyword\">const</span> taxi = <span class=\"hljs-keyword\">new</span> Taxi(<span class=\"hljs-string\">\"yellow\"</span>);\ntaxi.drive(); <span class=\"hljs-comment\">// GO! My yellow taxi!</span></code></pre>\n<h3 id=\"promise\"><a href=\"#promise\" class=\"phenomic-HeadingAnchor\">#</a>Promise</h3>\n<p>關於 <strong>Promise</strong> 的介紹我已經在先前有寫過一篇簡單的<a href=\"https://kevin940726.github.io/blog/2016/03/22/I-Promise-you-it-s-going-to-be-great/\">介紹文</a>了，歡迎前往觀看～</p>\n<h3 id=\"module-importexport\"><a href=\"#module-importexport\" class=\"phenomic-HeadingAnchor\">#</a>Module import/export</h3>\n<p>相信如果熟悉 Node.js 的環境的人都知道 <code>require()</code> 是什麼東西，如今在 bundler 的幫助下整個 js 的生態圈都已經 modulize 化了，除了後端，連前端都可以使用 <code>require()</code> 了，不過還是有許多不方便之處，而 es6 的 <code>import</code> 和 <code>export</code> 就是這個問題的很好的解決方案。</p>\n<p>首先是 module export 的寫法。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// module.js</span>\n<span class=\"hljs-comment\">// es5</span>\n<span class=\"hljs-built_in\">module</span>.exports = {\n    <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"bar\"</span>;\n    }\n};\n\n<span class=\"hljs-comment\">// es6</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n    foo() {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"bar\"</span>;\n    }\n};</code></pre>\n<p>在 import 時。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// es5</span>\n<span class=\"hljs-keyword\">var</span> Module = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'./module.js'</span>);\n<span class=\"hljs-built_in\">console</span>.log( Module.foo() ); <span class=\"hljs-comment\">// bar</span>\n\n<span class=\"hljs-comment\">// es6</span>\n<span class=\"hljs-keyword\">import</span> Module <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./module'</span>;\n<span class=\"hljs-built_in\">console</span>.log( Module.foo() ); <span class=\"hljs-comment\">// bar</span>\n\n<span class=\"hljs-comment\">// or</span>\n<span class=\"hljs-keyword\">import</span> { foo } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./module'</span>;\n<span class=\"hljs-built_in\">console</span>.log( foo() ); <span class=\"hljs-comment\">// bar</span></code></pre>\n<p>以上是一些基本的用法，不過還有很多在原本的 module 下比較難處理的用法。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// export</span>\n<span class=\"hljs-keyword\">export</span> { name1, name2 };\n<span class=\"hljs-keyword\">export</span> { variable1 <span class=\"hljs-keyword\">as</span> name1, variable2 <span class=\"hljs-keyword\">as</span> name2 };\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">let</span> name1 = foo, name2 = bar;</code></pre>\n<p><code>export default</code> 會讓其他檔案在 <code>import</code> 時指定預設的變數或 function。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> name1;\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">const</span> name1 = foo;</code></pre>\n<p>import 時預設會將 <code>export default</code> 的值 import 進來，如果只想要 import 其中的某些值或 method，使用類似 Destructuring 的語法會讓你的 code 更有系統和結構化，聰明的 bundler 會只幫你把需要的東西 import，省去不少空間和載入速度。用 <code>as</code> 來替引入的 module 改名。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// import</span>\n<span class=\"hljs-keyword\">import</span> name1 <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'module'</span>;\n<span class=\"hljs-keyword\">import</span> { name1, name2 } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'module'</span>;\n<span class=\"hljs-keyword\">import</span> { variable1 <span class=\"hljs-keyword\">as</span> name1, variable2 <span class=\"hljs-keyword\">as</span> name2 } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'module'</span>;\n<span class=\"hljs-keyword\">import</span> name1, { name2 } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'module'</span>;</code></pre>\n<p>使用 module 的 <code>import</code>/<code>export</code> 短短篇幅可能沒辦法解釋得非常清楚，有使用過的 Node.js 環境或接觸過其他類似語言(如 Python)的人可能比較能夠理解，詳細還是要自己常常使用才會比較清楚整體架構，不過這除了是使用 bundler 的核心價值以外，也有在開發上可以很有系統的做 code splitting 的優點，更好的除錯和大型專案 scale up 時帶來更清楚的架構，不管前後端都已經是不可或缺的一種開發模式了。</p>\n<h3 id=\"others\"><a href=\"#others\" class=\"phenomic-HeadingAnchor\">#</a>Others</h3>\n<p><strong>ES6</strong> 還有很多很好用的新功能，這裡只簡單介紹幾個我個人比較常用的，還有其他包括 <code>for...of</code>、<code>Map</code>、<code>Set</code>等非常好用的新功能，詳細可以看強者大大的<a href=\"https://github.com/lukehoban/es6features#readme\">整理</a>。</p>\n<h2 id=\"conclusion\"><a href=\"#conclusion\" class=\"phenomic-HeadingAnchor\">#</a>Conclusion</h2>\n<p>雖然瀏覽器還沒有全數支援所有的新功能，但是使用新的且穩定的功能在新的專案上已經是必然的趨勢，中大型專案如 <a href=\"https://github.com/reactjs/redux\">Redux</a> 和 facebook 的 <a href=\"https://github.com/facebook/draft-js\">draft.js</a> 都是直接使用 babel 撰寫的，所以不要因為好像要做一些特別的設定才能開始就排斥它，認為是一些邪門歪道 (XD)，趕緊跟上潮流才能當最強訓練家啊～不過當然也不建議直接開始使用 ES7 一些還在 stage 階段的功能 (如 async/await 等)，除了相對不穩定以外，未來也很有可能會更改，使用已經確定或是在社群中已經廣為使用的功能吧！</p>\n","__filename":"posts/Holy-Babel-Praise-the-ES6-Harmony.md","__url":"/posts/Holy-Babel-Praise-the-ES6-Harmony/","__resourceUrl":"/posts/Holy-Babel-Praise-the-ES6-Harmony/index.html","__dataUrl":"/posts/Holy-Babel-Praise-the-ES6-Harmony/index.html.227a0a56448a2525faed52e31ce2bfa1.json"}